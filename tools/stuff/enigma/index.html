<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ENIGMA</title>
    <style>
        /* CSS is here for a single-file solution */
        body {
            font-family: 'Consolas', monospace;
            background-color: #1a1a1a;
            color: #00ff41; /* Neon green text */
            margin: 0;
            padding: 10px; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            width: 95%; 
            max-width: 800px;
            border: 2px solid #00ff41;
            box-shadow: 0 0 15px #00ff41;
            padding: 20px; 
            background-color: #000000;
        }

        h1 {
            text-align: center;
            text-shadow: 0 0 5px #00ff41;
            margin-bottom: 20px; 
            font-size: 1.3em; 
        }
        
        /* General input/textarea styling */
        textarea {
            width: 100%;
            height: 150px;
            background-color: #0d0d0d;
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 10px; 
            margin-bottom: 15px; 
            box-sizing: border-box;
            font-size: 1em; 
            resize: none;
            outline: none;
            box-shadow: inset 0 0 5px #00ff41;
        }
        
        .key-input {
            margin-top: 15px;
        }
        .key-input input[type="text"] {
            width: 100%;
            background-color: #0d0d0d;
            border: 1px solid #00ff41;
            color: #ffcc00; 
            padding: 10px;
            box-sizing: border-box;
            font-size: 1em;
            outline: none;
            box-shadow: inset 0 0 5px #00ff41;
        }
        .key-input label {
            display: block;
            color: #00ff41;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        /* Controls/Button Styling */
        .controls {
            display: flex;
            justify-content: space-between;
            gap: 15px; 
            margin-bottom: 15px; 
        }

        button {
            flex-grow: 1;
            padding: 10px 15px; 
            background-color: #00ff41;
            color: #000000;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
            font-size: 0.9em; 
        }

        button:hover {
            background-color: #00e639;
            box-shadow: 0 0 10px #00ff41;
        }

        /* Responsive Breakpoint for Controls */
        @media (max-width: 600px) {
            .controls {
                flex-direction: column; 
            }

            button {
                width: 100%; 
                margin-bottom: 10px; 
                font-size: 1em; 
            }
            
            body {
                padding: 5px;
            }

            .container {
                padding: 15px;
                width: 100%;
            }
        }
        
        .copy-button-container {
            display: flex;
            justify-content: center;
            margin-top: 5px;
        }
        
        .copy-button-container button {
            width: 100%;
            max-width: 200px;
            padding: 5px 10px;
            background-color: #ffcc00;
            color: #000000;
            font-size: 0.8em;
        }
        
        .copy-button-container button:hover {
            background-color: #e6b800;
            box-shadow: 0 0 10px #ffcc00;
        }
    </style>
</head>
<body>

<!--cloudflare worker tracking only session IDs no user data-->
<script>
(function() {
  // --- Generate or read a unique session ID (session cookie) ---
  let sessionID = document.cookie.match(/sessionID=([^;]+)/)?.[1];
  if (!sessionID) {
    sessionID = crypto.randomUUID();
    document.cookie = `sessionID=${sessionID}; path=/`; // session cookie
  }

  // --- Set these per page/tool ---
  const type = 'tool';   // 'page' or 'tool'
  const name = 'enigma'; // unique page/tool name

  // --- Send data to Worker ---
  fetch('https://main-website-track.mahdiyasser526.workers.dev/', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ sessionID, type, name })
  }).catch(err => {
    console.error('Tracking failed:', err);
  });
})();
</script>
<!--worker end-->

    <div class="container">
        <h1>ENIGMA</h1>

        <label for="plain-text">Input Text (or Cipher to Decrypt):</label>
        <textarea id="plain-text" placeholder="Type your message here, or paste a cipher to decrypt..."></textarea>

        <div class="controls">
            <button onclick="encryptText()">Encrypt</button>
            <button onclick="decryptText()">Decrypt</button>
        </div>
        
        <label for="cipher-text" style="margin-top: 15px; display: block;">Cipher Output:</label>
        <textarea id="cipher-text" placeholder="Cipher output will appear here." readonly></textarea>
        
        <div class="key-input">
            <label for="cipher-key">Cipher Key (Optional Strong Layer)</label>
            <input type="text" id="cipher-key" placeholder="Enter a key for a strong extra layer. Leave blank for normal encryption." maxlength="100">
        </div>

        <div class="copy-button-container">
            <button onclick="copyOutput()">Copy Output</button>
        </div>
    </div>

    <script>
// --- Configuration: Defines the 9 UNIQUE layers (UNCHANGED) ---
const ENCODING_SEQUENCE = [
    'CUSTOM_B64',       // Layer 1: Fully custom Base64 (UTF-8 safe)
    'ADD_PADDING',      // Layer 2: Add custom noise
    'REVERSE_WORDS',    // Layer 3: Reverse the order of words
    'HEX_SWAP',         // Layer 4: Swap hex pairs
    'CHAR_OFFSET',      // Layer 5: Shift character ASCII values by a fixed offset
    'CHAR_SUBTRACT',    // Layer 6: Subtract character ASCII values
    'DIGIT_REPLACE',    // Layer 7: Replace digits 0-9 with custom chars
    'BASE_N_CONVERT',   // Layer 8: Convert number groups to a higher base (Base 16)
    'BASE64_VARIANT'    // Layer 9 (Final): Base64 using a modified alphabet
];
const PADDING_STRING = "XYZ_";
const PADDING_INTERVAL = 10;
const CHAR_SHIFT_OFFSET = 3;
const CHAR_SUB_KEY = 1; 
const DIGIT_MAP = {
    '0': '!', '1': '@', '2': '#', '3': '$', '4': '%',
    '5': '^', '6': '&', '7': '*', '8': '(', '9': ')'
};
const BASE64_VARIANT_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'; // Custom alphabet
// ------------------------------------------

// --- Strong Keyed XOR Layer (Optional Layer Logic - UNCHANGED) ---

/**
 * Applies a repeating Keyed XOR to the input text.
 * This is used for both encryption and decryption and handles all Unicode characters.
 * @param {string} text The input string.
 * @param {string} key The secret key string.
 * @returns {string} The XOR-ed output string.
 */
function applyKeyedXOR(text, key) {
    if (!key || key.trim() === '') return text;

    let result = '';
    const trimmedKey = key.trim();
    const keyLength = trimmedKey.length;

    for (let i = 0; i < text.length; i++) {
        // Get the character code of the current text character
        const charCode = text.charCodeAt(i);
        
        // Get the character code of the key character (repeating)
        const keyChar = trimmedKey.charCodeAt(i % keyLength);
        
        // Apply XOR and convert back to a character
        const xorResult = charCode ^ keyChar; 
        
        result += String.fromCharCode(xorResult);
    }
    return result;
}


// --- Custom Base64 Layer (Layers 1 and 9 - UNCHANGED) ---
function utf8ToCustomBase64(str) {
    const bytes = new TextEncoder().encode(str);
    let result = '';
    for (let i = 0; i < bytes.length; i++) {
        result += String.fromCharCode(bytes[i]);
    }
    return btoa(result);
}

function customBase64ToUtf8(str) {
    const binaryStr = atob(str); 
    const bytes = new Uint8Array(binaryStr.length);
    for (let i = 0; i < binaryStr.length; i++) {
        bytes[i] = binaryStr.charCodeAt(i);
    }
    return new TextDecoder("utf-8").decode(bytes);
}

function base64Variant(str) {
    const standardB64 = utf8ToCustomBase64(str); 
    let result = '';
    const standardAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for(const char of standardB64) {
        let index = standardAlphabet.indexOf(char);
        result += (index >= 0) ? BASE64_VARIANT_ALPHABET[index] : char;
    }
    return result;
}

function unBase64Variant(str) {
    let standardB64 = '';
    const standardAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for(const char of str) {
        let index = BASE64_VARIANT_ALPHABET.indexOf(char);
        standardB64 += (index >= 0) ? standardAlphabet[index] : char;
    }
    return customBase64ToUtf8(standardB64);
}

// --- Custom Obfuscation Layers (Layers 2-8 - UNCHANGED) ---
function addPadding(str) {
    let result = '';
    for (let i = 0; i < str.length; i += PADDING_INTERVAL) {
        result += str.substring(i, i + PADDING_INTERVAL) + PADDING_STRING;
    }
    return result;
}
function removePadding(str) {
    return str.replaceAll(PADDING_STRING, '');
}

function reverseWords(str) {
    return str.split(/\s+/).reverse().join(' ');
}
const unReverseWords = reverseWords;

function hexSwap(str) {
    let result = '';
    const paddedStr = (str.length % 2 !== 0) ? str + ' ' : str;
    for (let i = 0; i < paddedStr.length; i += 2) {
        result += paddedStr[i + 1] + paddedStr[i];
    }
    return (str.length % 2 !== 0) ? result.substring(0, result.length - 1) : result;
}
const unHexSwap = hexSwap;

function charOffset(str) {
    return str.split('').map(char => String.fromCharCode(char.charCodeAt(0) + CHAR_SHIFT_OFFSET)).join('');
}
function unCharOffset(str) {
    return str.split('').map(char => String.fromCharCode(char.charCodeAt(0) - CHAR_SHIFT_OFFSET)).join('');
}

function charSubtract(str) {
    return str.split('').map(char => String.fromCharCode(char.charCodeAt(0) - CHAR_SUB_KEY)).join('');
}
function unCharSubtract(str) {
    return str.split('').map(char => String.fromCharCode(char.charCodeAt(0) + CHAR_SUB_KEY)).join('');
}

function digitReplace(str) {
    let result = str;
    for (const [digit, symbol] of Object.entries(DIGIT_MAP)) {
        result = result.replace(new RegExp(digit, 'g'), symbol);
    }
    return result;
}
function unDigitReplace(str) {
    let result = str;
    for (const [digit, symbol] of Object.entries(DIGIT_MAP)) {
        result = result.replace(new RegExp('\\' + symbol, 'g'), digit);
    }
    return result;
}

function baseNConvert(str) {
    return str.replace(/(\d+)/g, (match) => {
        return `[B16:${parseInt(match, 10).toString(16).toUpperCase()}]`;
    });
}
function unBaseNConvert(str) {
    return str.replace(/\[B16:([0-9A-F]+)\]/g, (match, hexValue) => {
        return parseInt(hexValue, 16).toString(10);
    });
}


// --- Unified Layer Processing (UNCHANGED CORE LOGIC) ---
const PROCESSORS = {
    'CUSTOM_B64': { encode: utf8ToCustomBase64, decode: customBase64ToUtf8 },
    'ADD_PADDING': { encode: addPadding, decode: removePadding },
    'REVERSE_WORDS': { encode: reverseWords, decode: unReverseWords },
    'HEX_SWAP': { encode: hexSwap, decode: unHexSwap },
    'CHAR_OFFSET': { encode: charOffset, decode: unCharOffset },
    'CHAR_SUBTRACT': { encode: charSubtract, decode: unCharSubtract },
    'DIGIT_REPLACE': { encode: digitReplace, decode: unDigitReplace },
    'BASE_N_CONVERT': { encode: baseNConvert, decode: unBaseNConvert },
    'BASE64_VARIANT': { encode: base64Variant, decode: unBase64Variant }
};

function processLayers(input, direction) {
    let result = input;
    let sequence = ENCODING_SEQUENCE;

    if (direction === 'decode') {
        sequence = [...ENCODING_SEQUENCE].reverse();
    }

    for (let i = 0; i < sequence.length; i++) {
        const step = sequence[i];
        const processor = PROCESSORS[step];

        if (!processor) {
            throw new Error(`Unknown layer defined: ${step}`);
        }

        const func = (direction === 'encode') ? processor.encode : processor.decode;
        
        try {
             result = func(result);
        } catch (e) {
            console.error(`Error processing layer ${step} in ${direction}:`, e);
            throw new Error(`Layer Error at ${step}. Input length: ${result.length}.`);
        }
    }

    return result;
}


// --- Copy Functionality (UNCHANGED) ---
function copyOutput() {
    const outputElement = document.getElementById('cipher-text');
    const textToCopy = outputElement.value;

    if (!textToCopy.trim()) {
        alert('Nothing valid to copy.');
        return;
    }
    
    const tempTextArea = document.createElement('textarea');
    tempTextArea.value = textToCopy;
    tempTextArea.style.position = 'fixed';
    tempTextArea.style.top = '0';
    tempTextArea.style.left = '-9999px';
    
    document.body.appendChild(tempTextArea);
    tempTextArea.focus();
    tempTextArea.select();
    
    let success = false;
    try {
        success = document.execCommand('copy'); 
    } catch (err) {
        console.error('Fallback copy failed:', err);
    }
    
    document.body.removeChild(tempTextArea);

    if (success) {
        alert('Output copied to clipboard!');
    } else {
        alert('Failed to copy text. Your browser may require manual selection.');
    }
}


// --- Main Application Functions (Conditional Logic Using Strong XOR - UNCHANGED) ---
function encryptText() {
    const plainTextarea = document.getElementById('plain-text');
    const cipherTextarea = document.getElementById('cipher-text');
    const keyInput = document.getElementById('cipher-key');
    
    let text = plainTextarea.value;
    const userKey = keyInput.value.trim();

    if (text.trim() === '') {
        cipherTextarea.value = 'ERROR: Input field is empty. Cannot encrypt.';
        return;
    }
    
    try {
        // STEP 1: OPTIONAL STRONG KEY LAYER (Keyed XOR)
        if (userKey.length > 0) {
            text = applyKeyedXOR(text, userKey);
        }
        
        // STEP 2: MANDATORY 9-LAYER ENCRYPTION CHAIN
        let cipher = processLayers(text, 'encode');
        
        cipherTextarea.value = cipher;

    } catch (e) {
        cipherTextarea.value = `FATAL ENCRYPTION ERROR: ${e.message}`;
    }
}


function decryptText() {
    const plainTextarea = document.getElementById('plain-text');
    const cipherTextarea = document.getElementById('cipher-text');
    const keyInput = document.getElementById('cipher-key');

    let cipherText = plainTextarea.value; 
    const userKey = keyInput.value.trim();

    if (cipherText.trim() === '') {
        cipherTextarea.value = 'ERROR: Input field is empty. Cannot decrypt.';
        return;
    }
    
    try {
        // STEP 1: MANDATORY 9-LAYER DECRYPTION CHAIN
        let result = processLayers(cipherText, 'decode');

        // STEP 2: OPTIONAL STRONG KEY LAYER (Reverse Keyed XOR)
        if (userKey.length > 0) {
            result = applyKeyedXOR(result, userKey);
        }

        cipherTextarea.value = result;
        
    } catch (e) {
        cipherTextarea.value = `FATAL DECRYPTION ERROR: ${e.message}. Check if the input is correct, if the key was used, and if the key is correct.`;
    }
}
    </script>
</body>
</html>
